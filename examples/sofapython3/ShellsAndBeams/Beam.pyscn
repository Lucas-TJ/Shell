import Sofa
import SofaPython
from math import sin,cos, sqrt


import os
path = os.path.dirname(os.path.abspath(__file__))+'/'

radius=25.4;
PI= 3.14159265359
dt=0.04
gravity = 9810



class measurementControlBeam(Sofa.PythonScriptController):
    
    def initGraph(self, node):
        self.node = node
        self.time=0;  # time will go between 0 and time_nextStep 
        
        
        self.loadingTable = [0,5,10,15,20,25,30,35,40,45,50,50] #[0,1,2,3,4,5,6,7,8,9,10,10] # loading 
        self.step=0;
        
        self.pressure =  6894.0* 0;
        self.forceZ = 0;
        self.deflectionData=[]
        
    def onEndAnimationStep(self, dt):
        self.time= self.time+dt;
        time_loading = 1;
        time_nextStep = 2;
        
        time_loadingPressure=0.16;
        
        if (self.step == 0):
            # witing for the pressure inside the shell
            
            if (self.time >= time_loadingPressure):
                self.time = 0; 
                self.step=1; 
            
            return;
            
            
            
            
            
        
        if (self.time< time_loading):
            # progressive loading + then stabilisation 
            loading_factor = self.time/ time_loading # between 0 and 1 
            weight  =  self.loadingTable[self.step-1]*(1-loading_factor) + self.loadingTable[self.step]*loading_factor;       
            self.forceZ = -weight * gravity;
            
            forceValue1 = self.node.getObject('load').findData('totalForce')
            forceValue1.value = '0 0 '+str(self.forceZ)+'  0 0 0'
            
            
        elif (self.time >= time_nextStep):
            # store the measurement 
            
            print '************ beam measure step '+str(self.step)+ '**************'
            self.step = self.step+1
            
            
            rootNode = self.node.getParents()
            
            print(rootNode)
            
            background= rootNode[0].getObject('BackgroundSetting')

                    
            backgroundValue= background.findData('image')
            data = 1030725 + self.step
            backgroundValue.value = path+'images/P'+str(data)+'.JPG'
            
            background.init()

            

            
            
         
            
            if (self.step > len(self.loadingTable)-1) : 
                self.step = self.step-1;
                print '------------ final Result with beams ------------'
                print self.deflectionData 
                
            self.time = 0.0
            
            
            
            position = self.node.getObject('MechanicalObject').findData('position').value
            rest_position= self.node.getObject('MechanicalObject').findData('rest_position').value
            
            numNodes=len(position)
            i1 = numNodes-1
            
            deflection=(position[i1][2] - rest_position[i1][2]) 
            
            print 'force = '+str(self.forceZ)
            print 'dx = '+str(deflection)

            self.deflectionData = self.deflectionData + [-deflection ]
            

        
        
        



print "**************************** README **********************************"
print "This scene makes a beam model (with rigid dofs) "
print "It assumes that the beam a cylinder with a thin thickness alligned with the axis x"
print "the mesh is symetric and can be loaded on nodes positioned at x=0"
print "**********************************************************************"


def transformTableInString(Table):
	sizeT =  len(Table);
	strOut= ' ';
	for p in range(sizeT):
		strOut = strOut+ str(Table[p])+' '

	return strOut


#Takes a n dimensional vector of vector and transform it into a simple vector 
def transformDoubleTableInSimpleTable(Table):
    size0 =  len(Table);

    # count the size
    size=0;
    for i in range(size0):
        size = size+len(Table[i]);

    TableOut=[0]*size;
    s=0;
    for i in range(size0):
        for j in range(len(Table[i])):
            TableOut[s] = Table[i][j];
            s=s+1;

    return TableOut



def createScene(rootNode):
    rootNode.createObject('RequiredPlugin', name='SoftRobots')
    rootNode.createObject('RequiredPlugin', name='BeamAdapter')
    rootNode.createObject('RequiredPlugin', name='SofaPython')
    rootNode.createObject('RequiredPlugin', name='SofaShells')
    rootNode.createObject('VisualStyle', displayFlags='showVisualModels hideBehaviorModels showCollisionModels hideBoundingCollisionModels showForceFields showInteractionForceFields hideWireframe')
    rootNode.findData('gravity').value= '0. 0 0';
    
    
    
    rootNode.findData('dt').value= dt;

    rootNode.createObject('FreeMotionAnimationLoop')
    rootNode.createObject('GenericConstraintSolver', maxIterations='1000', tolerance='1e-15')
    rootNode.createObject('CollisionPipeline', verbose='0')
    rootNode.createObject('CollisionResponse', response='FrictionContact', responseParams='mu=0.5')
    rootNode.createObject('BruteForceDetection', name='N2')
    
    alarmDistance=0.2
    rootNode.createObject('LocalMinDistance', name="Proximity", alarmDistance=alarmDistance, contactDistance="0.1", angleCone='0.1')

    rootNode.createObject('BackgroundSetting', color='0 0.168627 0.211765' , image=path+'images/P'+str(1030725)+'.JPG')#, image =path+'grille.jpeg' )
    rootNode.createObject('OglSceneFrame', style="Arrows", alignment="TopRight")

    

    # distance in mm
    # poid en gramme
    # conversion PSI en unite de la scene 
    # 1 PSI = 6894.76 Pa  =   6894.76 kg/m.s^2  = 6894.76 g/mm.s^2
    
    # 4v = 1 PSI
    # 7v = 2 PSI
    # 10v = 3 PSI
    
    # https://www.makeitfrom.com/material-properties/Low-Density-Polyethylene-LDPE
    # Young Modulus = 0.3 GPa
    # Shear Modulus = 0.21 GPa
    
    # density = 0.92 g/cm^3   => 0.00092g/mm^3
    
    YoungModulus=3e8
    density = 0.00092 ;
    Thickness= 0.050;
    length=500

    volume = 2*PI*radius*length* Thickness
    
    # measured mass= 2.88
    mass = volume*density
    
    #mass='10'

    
    PSI = 3;

    # in grams
    weight = 1;
    
    initPressure= 1* 6894.0* PSI;
    
    
    
    
        
    #########################################
    # Mapped Pseudo Beam 
    #########################################
    
    beamNode = rootNode.createChild('beamMechanics')
    beamNode.createObject('EulerImplicitSolver', firstOrder="1", rayleighStiffness=0.0, rayleighMass='100')
    beamNode.createObject('BTDLinearSolver', name='solver')
    beamNode.createObject('GenericConstraintCorrection', solverName="solver")
    
    rg=beamNode.createObject('RegularGrid', min='0 30 0' , max='500 30 0', computeHexaList='0', computeQuadList='0', n='20 1 1')
    rg.init()
    numNodes= len(rg.findData('position').value)
    
    beamNode.createObject('MechanicalObject', template='Rigid')
    beamNode.createObject('BeamInterpolation', name='tubeInterpolation', radius=radius, innerRadius=radius-Thickness, straight='1', defaultYoungModulus=YoungModulus)
    beamNode.createObject('AdaptiveInflatableBeamForceField', massDensity=density, pressure=initPressure)
    beamNode.createObject('FixedConstraint', indices='0')
    
    beamNode.createObject('PythonScriptController', classname="measurementControlBeam")   
    beamNode.createObject('ConstantForceField', name='load', totalForce='0 0 0 0 0 0', arrowSizeCoef='0.001', indices=numNodes-1)
    
    
    mapped = beamNode.createChild('visualMapped')
    loader=mapped.createObject('GIDMeshLoader', name='loader', filename=path+'winstonTube2Dim_mm.msh', scale='1', rotation='90 0 0');
    mapped.createObject('Mesh', src='@loader')
    mapped.createObject('MechanicalObject', template='Vec3', position='@loader.position', showObject='1', scale3d='1 '+str(radius/9.5)+' '+str(radius/9.5))
    
    mapped.createObject('AdaptiveBeamMapping', interpolation='@../tubeInterpolation')
    
    visual = mapped.createChild('visualModel')
    visual.createObject('OglModel')
    visual.createObject('IdentityMapping')
    
    
    #beamNode.createObject('MappingGeometricStiffnessForceField',mapping="@./length/beamLMap" )
    #lengthNode = beamNode.createChild('length')
    


    
    return rootNode      
