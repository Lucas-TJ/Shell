\chapter{Modelling the deformation of solid objects in real-time}
\label{chap4}
\begin{shortAbstract}
A short abstract for the upcoming chapter
\end{shortAbstract}


\section{Introduction: the problematic}

At the beginning of computer simulation, users were immersed into environments that were merely a decor. If it could virtually take the user somewhere else, a static scene quickly showed its limits. Indeed, in a real-life environment many objects are in motion, interacting with each others. Therefore, in order to increase the fidelity of simulations, elements of physics were progressively added. It could be as simple as adding motion to clouds in a flight simulator for instance. But by improving the dynamism of the scene, the simulation appears more natural to users. Over time, with the increase in computational power of computers, objects stopped being all rigid and simulators started taking laws of physics into account. In other words, they became deformable. If this took the realism a step further, demands in computational power were multiplied. Simulators eventually faced a challenge: they had to weight the desired degree of realism against the computational power at their disposal. 

In the field of medical simulation, the correctness of deformation is often crucial. This is particulary true in the cases of per-operative guidance. As an example, removing a brain tumor relies heavily on knowing the spatial relation between the patient's brain and the images acquired prior to surgery. Unfortunately, drilling a hole into the patient's skull releases pressure and the brain deforms. This phenomenon is called brain shift. The overall deformation is quite complex and the displacements depend on local elasticity of the brain, the size and the location of the tumor. A large brain shift, if not corrected, will result in inaccuracies in the surgical procedure and has the potential to cause damage to normal tissue. A solution is to accurately model the mechanical response of the patient's brain to predict the actual deformation and hence keep the knowledge of the tumor's location. 

Conversely, when medical simulation is applied to training, such a precision in terms of distance is not required. The physician would not even visually notice reasonable errors as soon as it looks realistic enough. However, in some medical procedures, the sense of touch and the forces that the physician can feel are a fey factor for the success of the operation. For instance, during a colonoscopy procedure, force feedback gives precious information about what type of loop is forming and the physician can then react accordingly to prevent loop formation. Consequently, a good colonoscopy simulator is required to provide accurate force feedbacks. If the contact forces were not reproduced to the operator, he would never be able to learn how to detect loop forming. Obviously, the computation of a realistic force to be returned demands an appropriate mechanical modelling of all structures. 

If the reasons differ, the need for modelling the mechanical response of organs with precision remains. However, strong time constraints often limit the complexity of the modelling and affects the overall accuracy. Because of this trade-off, various approaches were proposed over the years to fit into real-time constraints and may be grouped into three main categories: (1) geometrically based techniques, (2) approaches physically motivated usually relying on Newton's second law and (3) methods actually based on the equations of continuum mechanics. 



\section{Techniques based on geometry}

	\subsection{Free-form deformation}
The first needs to deforming solid objects came from for the field of solid modelling. The goal was to allow the designer to shape an object into the form he wishes in a similar way that clay is manipulated by a sculptor's hands. \cite{Sederberg86} introduced a technique called \emph{free-form deformation} based on the paper of \cite{Barr84}. It involves a mapping from $ \field{R}^3 $ to $ \field{R}^3 $ through a tensor product trivariate Bernstein polynomial. The deformed shape of the object is interpolated using control points as in the case of Bézier curves and surfaces patches (see Fig.~{chap4:fig-cubeFFD}). 
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=6.5cm]{chapter4/cubeFFD1.pdf}
\includegraphics[width=6.6cm]{chapter4/cubeFFD2.pdf}
\end{center}
\caption[Deformation of objects by free-form deformation]{Let us imagine that the objects that we want to deform (spheres and cubes) are placed into a transparent parallelepiped. Control points are indicated by small white diamonds. The free-form deformation technique offers to compute the deformation of the objects from the positions of the control points (right).}
\label{chap4:fig-cubeFFD}
\end{figure}
The capability of locally applying deformations makes the technique strongly analogous to sculpting with clay, which was the sought target. Although the authors do not give details on computational efficiency, their work constitutes the beginnings of deformable solid objects. 

Coquillard later developed the idea of Extented free-form deformation \citeyearpar{Coquillart90} and Animated free-form technique \citeyearpar{Coquillart91}. The idea of free-form deformation with lattices of arbitrary topology was introduced by \cite{MacCracken96}. Finally, \cite{Schein04} presented a technique to facilitate the incorporation of discontinuities in a model while deforming it. 


	
	\subsection{Shape matching}
One field particulary interested in modelling deformable objects in a very efficient way is the game industry. Of course, for games we are more attracted by computational efficiency and extreme stability features than accuracy to physics laws. Most of the time, we can tolerate a degradation of realism as long as the result looks realistic. \cite{Muller05} developed a technique with this idea in mind called \emph{shape matching}. We start with a set of particules with masses $ m_i $ in an initial configuration where we denote by $ \mathbf{x}_i^0 $ the initial positions of the particules. No connectivity information is required. The particles are simulated as a simple particle system without particle-particle interactions, but including response to collisions with the environment and including external forces such as gravity. The positions in the deformed configuration are noted $ \mathbf{x}_i $. The method consists of finding a set of points $ \mathbf{g}_i $ which minimises the difference between the two sets $ \mathbf{x}_i^0 $ and $ \mathbf{x}_i $. The first step is to find the rotation matrix $ \mathbf{R} $ and the translation vectors $ \mathbf{t} $ and $ \mathbf{t}_0 $ such that
\begin{equation}
\sum_i m_i (\mathbf{R}(\mathbf{x}_i^0 - \mathbf{t}_0) + \mathbf{t} - \mathbf{x}_i)^2
\end{equation}
is minimal. The optimal translation vectors $ \mathbf{t} $ and $ \mathbf{t}_0 $ turn out to be the centre of mass of the initial shape and actual shape, that we will note $ \mathbf{x}_{c}^0 $ and $ \mathbf{x}_c $, respectively. The optimal rotation matrix is found by first finding the optimal linear transformation $ \mathbf{A} $. The optimal rotation is eventually obtained through the rotational part of $ \mathbf{A} $ after a polar decomposition. Finally, the goal positions $ \mathbf{g}_i $ can be computed as follows:
\begin{equation}
\label{chap4:gi}
\mathbf{g}_i = \mathbf{R}(\mathbf{x}_i^0 - \mathbf{x}_{c}^0) + \mathbf{x}_{c}.
\end{equation}
Once the goal positions are known, they are used to integrate the positions of the particules:
\begin{equation}  
	\begin{cases} 
		\mathbf{v}_i(t+h) = \mathbf{v}_i(t) + \alpha \dfrac{\mathbf{g}_i(t) - \mathbf{x}_i(t)}{h}  + h \dfrac{f_{\text{ext}}(t)}{m_i} \\\\
		\mathbf{x}_i(t+h) = \mathbf{x}_i(t) + h \mathbf{v}_i(t+h)
	\end{cases}
\end{equation}
where $ \alpha $ is a parameter between $ 0 $ and $ 1 $ which simulates stiffness. Because the method in this basic form is not suitable for objects undergoing large deformations, it is then extended to linear and quadratic deformations by replacing $ \mathbf{R} $ in \eqref{chap4:gi} with combinations of the form $ \beta \mathbf{A} + (1-\beta) \mathbf{R}$ where $ \beta $ is an additional parameter. Linear transformation can represent shear and stretch while quadratic transformation add twist and bending. Of course, this technique is not physically realistic. But this is beyond the point. This method allows the authors to simulate hundreds of deformable objects at an interactive rate with an unconditional stability (see Fig.~\ref{chap4:fig-shoes}). Another illustration of this stability is shown Fig.~\ref{chap4:fig-duck}. 
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=13.9cm]{chapter4/shoes.pdf}
\end{center}
\caption[Shape matching technique]{Shape matching allows to simulate hundreds of deformable objects in real-time.}
\label{chap4:fig-shoes}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=11cm]{chapter4/duck1.pdf} \\
\vspace{0.1cm}
\includegraphics[width=11cm]{chapter4/duck2.pdf}
\end{center}
\caption[Squeezing of a duck using Shape Matching]{A duck model is squeezed to demonstrate the stability of the shape matching technique. Although the flat shape of the duck is not physically plausible, this example exposes the impressive ability of the approach to recover from highly deformed or inverted configurations.}
\label{chap4:fig-duck}
\end{figure}
	
Later, \cite{Rivers07} extented the technique to regular lattices with embedded geometry. From a surface mesh to be deformed, they start by voxelising the model to construct a lattice of cubic cells containing the mesh. The embedded mesh is then deformed using trilinear interpolation of lattice vertex positions. A particule is placed at each vertex of the lattice and associated with a shape matching region. Their technique of \emph{Fast Lattice Shape Matching} allows them to compute per-region transformations in an efficient manner (see Fig.~\ref{chap4:fig-penguins}).	
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=13.9cm]{chapter4/penguins.pdf}
\end{center}
\caption[Penguins animation with Fast Lattice Shape Matching]{(Left) $150$ cartoon penguins deforming dynamically using Fast Lattice Shape Matching. (Right) Deformed lattices consisting of $150$ particles per penguin ($22\,500$ particles). The penguins can be deformed at $25$ frames per second on a Pentium4 $3.4 \,$GHz.}
\label{chap4:fig-penguins}
\end{figure}

One limitation of fast lattice shape matching is that small features of a geometry yield an explosion of the runtime cost. Indeed, a small surface feature may require fine sampling in order to be deformed independently from non-adjacent material, but this fine sampling must be applied to the whole object. Therefore, \cite{Steinemann08} further improved the technique by allowing dynamic adaptive selection of levels of detail through the use of an octree-based hierarchical sampling. This adaptative sampling is illustrate with Fig.~\ref{chap4:fig-flowers}. Their technique also handles efficient topological changes.
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=13.9cm]{chapter4/flowers.pdf}
\end{center}
\caption[Flowers in the wind]{Complex scene with $40$ deforming flowers. A coarse sampling is employed when the flowers are moved by the wind, for a total of $5\,680$ nodes in the scene. However, the models are dynamically refined when touched by the user, as shown in the left image.}
\label{chap4:fig-flowers}
\end{figure}	

Although realism is not a crucial feature for game-like environments, other models based on laws of physics were created for other applications.

	
\section{Techniques relying on physics}

	\subsection{3D Chainmail algorithm}
The \emph{3D Chainmail} was introduced by \cite{Gibson97} as a fast algorithm for deforming solid objects. Rather than carrying out complex computations on a low resolution geometry (as opposed to FEM techniques), the main idea is to take advantage of the original data resolution (of a CT scan for instance) but perform simple deformation calculation for each element. In this algorithm, each volume element is linked to its six nearest neighbours. If a link between two nodes is stretched to its limit, displacements are transferred to its neighbouring links. It works in a very similar way to a chain and is illustrated by Fig.~\ref{chap4:fig-chainmail}. 
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=12cm]{chapter4/chainmail.pdf}
\end{center}
\caption[Deformation of a 2D chain]{Deformation of a 2D chain mail when the link indicated by an arrow is moved.}
\label{chap4:fig-chainmail}
\end{figure}	
%
The chain mail algorithm is then followed by an elastic relaxation, which relaxes the shape of the deformed object approximated by the chain mail algorithm. This step consists of minimising an elastic energy measure within the object to insure that the calculated deformation is a minimum energy configuration. 

This method was extented by \cite{Schill98} to integrate inhomogeneous and anisotropic behaviour. This extension of the chain mail algorithm allows the authors to simulate the vitrous humor in the eye during a vitrectomy procedure. However, the main drawback of this algorithm is that it does not model volume preservation, an important characteristic of many tissues in the human body. 


	\subsection{Modal analysis}
\emph{Modal analysis} was first introduced to the graphics community by \cite{Pentland89} as a fast method for approximating deformation. Modal analysis is the process of taking the non-linear description of a system, finding a good linear approximation, and then finding a coordinate system that diagonalises the linear approximation. This process transforms a complicated system of non-linear equations into a simple set of decoupled linear equations that may be individually solved analytically \citep{Hauser03}. Moreover, because each decoupled equation may be solved analytically, stability concerns due to the choice of a time integration procedure are eliminated. The linearised system of equations may be written as:
\begin{equation}
\label{chap4:linearisedEquation}
\mathbf{M} \mathbf{\ddot U} + \mathbf{D} \mathbf{ \dot U} + \mathbf{K} \mathbf{U} = \mathbf{R}.
\end{equation}	
where $ \mathbf{M} $ is the mass matrix, $\mathbf{D}$ is the damping matrix, $ \mathbf{K} $ is the stiffness matrix and $\mathbf{R}$ are externally applied loads. Modal decomposition refers to the process of diagonalising equation \eqref{chap4:linearisedEquation}. By using Rayleigh damping (see discussion on damping in section \ref{chap3:wordOnMatrices}), \eqref{chap4:linearisedEquation} may be rewritten as:
\begin{equation}
\label{chap4:eqRayleigh}
\mathbf{K} (\mathbf{U} + \alpha_1  \mathbf{ \dot U}) + \mathbf{M} (\alpha_2 \mathbf{ \dot U} + \mathbf{\ddot U})  = \mathbf{R},
\end{equation}	
where $ \alpha_1 $ and $ \alpha_2 $ are the Rayleigh coefficients. We denote $ \mathbf{W} $ the solution to the generalised eigenproblem $ \mathbf{K} \mathbf{x} + \lambda \mathbf{M} \mathbf{x} = 0 $ and $\boldsymbol \Lambda$ the diagonal matrix of eigenvalues, then \eqref{chap4:eqRayleigh} may be expressed as:
\begin{equation}
\boldsymbol \Lambda (\mathbf{Z} + \alpha_1  \mathbf{ \dot Z}) + (\alpha_2 \mathbf{ \dot Z} + \mathbf{\ddot Z})  = \mathbf{G},
\end{equation}
where $ \mathbf{Z} = \mathbf{W}^{-1} \mathbf{U} $ is the vector of modal coordinates and $ \mathbf{G} = \mathbf{W}^T \mathbf{U} $ is the external force vector in the modal coordinate system. Each row of this equation now corresponds to a single scalar differential equation:
\begin{equation}
\ddot z_i + (\alpha_1 \lambda_i +\alpha_2) \dot z_i + \lambda_i z_i = g_i.
\end{equation}
The analytical solutions to each equations are well known and are the following:
\begin{equation}
z_i = c_1 e^{t \omega_i^+} + c_2 e^{t \omega_i^-}
\end{equation}
where $ c_1 $ and $ c_2 $ are complex constants and $ \omega_i $ is the complex frequency given by:
\begin{equation}
\omega_i^{\pm} = \dfrac{-(\alpha_1 \lambda_i + \alpha_2) \pm \sqrt{(\alpha_1 \lambda_i +\alpha_2)^2 - 4 \lambda_i}}{2}.
\end{equation}
The main advantage of modal analysis is the possibility to model only the necessary modes. Indeed if the eigenvalue $ \lambda_i $ associated with a particular mode is large, then the force required to cause a discernible displacement of that mode will also be large. Similarly, some displacements may be too small to be detected. Removing those modes from the computation will not change the appearance of the resulting simulation while substantially reducing the computational cost. 

\cite{James02} went even further by using graphics hardware to reduce CPU costs to a minimum. In particular, they use modal analysis to model human skin and secondary tissues in a laparascopic surgical simulation to allow the CPU to focus on more complex tissue models and user contact interactions (see Fig.~\ref{chap4:fig-modalAnalysisLaparo}). The technique is fairly efficient as it allows precomputations of the vibration modes. 
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=13cm]{chapter4/modalAnalysisLaparo.pdf}
\end{center}
\caption[Applications of modal analysis]{(Left) A jumping motion that leads to significant thigh and belly vibrations of human skin when rendered with modal analysis. (Right) The same hardware accelerated technique is applied to secondary tissues in a laparoscopic simulation to ease the CPU of computations. } 
\label{chap4:fig-modalAnalysisLaparo}
\end{figure}	

Although modal analysis significantly accelerates the simulation, it generates noticeable artifacts when applied to large deformations due to the step of linearisation. It can produce unnatural results with deformations of large amplitude. \cite{Choi05} proposed to overcome this limitation by taking the rotational component of the deformation into account at each node. \cite{Barbic05} make use of modal analysis to build a deformation basis from modal derivatives. It allows them to simulate large deformations of solid objects with non-linear material. 


	\subsection{Mass-spring model}
A classic technique for modelling a deformable object is the mass-spring system. In this method, the geometry is described by a network of masses connected together by springs. The force $ F $ exerted onto each mass by the spring may be computed with:
\begin{equation}
\label{chap4:massSpring1}
F_{\text{spring}} = - k x,
\end{equation}
where $ k $ is the spring stiffness constant, $ x $ represents the stretch of the spring from its rest position. From our experience, we know that a mass attached to a single spring has a tendency to oscillate. If no appropriate measure is taken, a network of springs will a forciori oscillate as well. To prevent the system from oscillating, a damper is also added between each couple of masses. The force created by the damper acts to reduce the velocity and may be expressed as:
\begin{equation}
\label{chap4:massSpring2}
F_{\text{damper}} = - d v
\end{equation}
where $ d $ is the damping constant and $ v $ the derivative of $ x $ with respect to time. The damper added between each couple of masses allows to model friction and reduce the amplitude of the oscillations. Applying Newton's second law $ \sum \mathbf{F} = m \mathbf{a} $ yields the standard differential equation for a mass-spring system:
\begin{equation}
\label{chap4:massSpring3}
m \ddot x = - d \dot x - k x.
\end{equation}
For complex systems with more than one spring attached to each mass, the right-hand side of the equation above becomes more complex as it needs to be repeated and adjusted for each spring. The easiest way to solve a complex mass-spring system iteratively, is to first calculate the total force currently acting on each mass by summing all forces currently exerted by all springs attached to this mass (using \eqref{chap4:massSpring1} and \eqref{chap4:massSpring2}). Dividing the total force by the mass gives the current acceleration of each mass (by \eqref{chap4:massSpring3}). This equation must be numerically solved for each mass, either by explicit or implicit methods. A discussion of integration methods for mass-spring models can be found in \cite{Shinya05}. 

Mass-spring systems have been extensively used and are still very popular. And this is not surprising because they are easy to implement and computationally efficient. Of course, they have drawbacks. But as we will see shortly, various recent works attempt to circumvent them. One limitation often mentioned is the difficulty to derive spring stiffnesses from elastic properties (Young's modulus and Poisson's ratio). To overcome this deficiency, \cite{Lloyd07} mention two ways of obtaining the parameters of a mass-spring model. The first one consists in varying the parameters until the behaviour of the system is similar to the one obtained through the experiments or the one obtained with the Finite Element Method \citep{Bianchi04}. The second way consists in establishing an analytical reasoning for calculating the constants of the mass-spring model. For instance, starting from the definition of Young's modulus, Poisson's ration, shear and bulk modulus, \cite{Baudet07} apply simple tests to their mass-spring model to find the most appropriate stiffnesses. \cite{Lloyd07} proposes a linearisation of the mass-spring equations with the aim of equating the linearised stiffness matrix to the stiffness matrix of a linear finite element method. By following the same method, \cite{SanVicente09} derived a mass-spring model equivalent to a linear finite element model for maxillofacial surgery simulation. 

Because they do not derive from the equations of continuum mechanics, mass-spring models have a limited capacity to model the various aspects of a material like anisotropy, viscoelasticity etc. Even worse, according to \cite{Bourguignon00}, if all springs are set to the same stiffness, the mesh geometry may generate undesired anisotropy as shown in Fig.~\ref{chap4:fig-undesiredAnisotropy}. However, some works tried to take advantage of this feature by giving directions of interest to their model by specifically designing the mesh to align springs on specific directions. For instance, it was used by \cite{Miller88} to animate the motion of snakes and worms. It was also used by \cite{Ng-Thow-Hing97} in their muscle model where some of the springs were aligned with the muscle fibers and more recently by \cite{Magjarevic09} for modelling the mechanical behavior of the myocardial tissue. More details on controlling anisotropy in mass-spring systems may be found in \cite{Bourguignon00}. 
%
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{chapter4/undesiredAnisotropy.pdf}
\end{center}
\caption[Undesired anisotropy with mass-spring models]{The two meshes are undergoing a downward pull at their bottom. While the tetrahedral mass-spring system (left) shows signs of anisotropy, the hexahedral mesh (right) with springs aligned along the gravity does not.} 
\label{chap4:fig-undesiredAnisotropy}
\end{figure}	

A mass-spring model may also be enhanced to feature viscoelasticity. Indeed, \cite{Stiles72} proposed a viscoelastic mass-spring system to test hypotheses on the mechanical response of muscles. Much more recently, \cite{Tamura05} introduced a method to simulate viscoelastic material using a spring-mass system. They use a large number of particules to create a randomly connected mesh to mimic the structure of polymeric materials and hence their viscoelascity characteristics. \cite{Basafa10} went even further and extended a mass-spring system to simulate non-linear viscoelastic deformations of soft tissue for laparoscopic surgery. They tune their parameters by a simple optimisation procedure to fit the mechanical response obtained on a set of experimental data. 


The most complete mathematical formalism available to describe the mechanical behaviour of a solid is provided by continuum mechanics. Consequently, it feels natural to derive computational models from the equations of continuum mechanics and a few techniques based on these equations will now be introduced. 
	
		
\section{Techniques based on continuum mechanics}	
	

	\subsection{FEM with mesh (highlight evolution: linear, topological changes, co-rotational, non-linear, GPU)}
	
	\subsection{Meshless, position-based dynamics (supposedly good for handling topological changes but other issues)}
	
	
	