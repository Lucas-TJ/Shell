\documentclass{egpubl}
\usepackage{vriphys2012}

% --- for  Annual CONFERENCE
% \ConferenceSubmission % uncomment for Conference submission
% \ConferencePaper      % uncomment for (final) Conference Paper
% \STAR                 % uncomment for STAR contribution
% \Tutorial             % uncomment for Tutorial contribution
% \ShortPresentation    % uncomment for (final) Short Conference Presentation
%
% --- for  CGF Journal
% \JournalSubmission    % uncomment for submission to Computer Graphics Forum
% \JournalPaper         % uncomment for final version of Journal Paper
%
% --- for  EG Workshop Proceedings
\WsSubmission    % uncomment for submission to EG Workshop
% \WsPaper         % uncomment for final version of EG Workshop contribution
%
 \electronicVersion % can be used both for the printed and electronic version

% !! *please* don't change anything above
% !! unless you REALLY know what you are doing
% ------------------------------------------------------------------------

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filename within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\PrintedOrElectronic

% prepare for electronic version of your document
\usepackage{t1enc,dfadobe}

\usepackage{egweblnk}
\usepackage{cite}

% For backwards compatibility to old LaTeX type font selection.
% Uncomment if your document adheres to LaTeX2e recommendations.
% \let\rm=\rmfamily    \let\sf=\sffamily    \let\tt=\ttfamily
% \let\it=\itshape     \let\sl=\slshape     \let\sc=\scshape
% \let\bf=\bfseries

% end of prologue

% ------------------------------------------------------------------------

\usepackage{ucs}
\usepackage[utf8x]{inputenc}

\usepackage{amsmath}

% Partial derivative
\newcommand{\deriv}[2]{\frac{\partial #1}{\partial #2}}
% Matrix
\newcommand{\mat}[1]{\mathbf{#1}}

%\Figure{width}{name}{caption}
\newcommand{\Figure}[3]{%
\begin{figure}[htb]
  \centering
  \includegraphics[width=#1]{#2}
  \caption{\label{fig-#2}#3}
\end{figure}}

% For large/wide figures
%\FigureW{width}{name}{caption}
\newcommand{\FigureW}[3]{%
\begin{figure*}[htb]
  \centering
  \includegraphics[width=#1]{#2}
  \caption{\label{fig-#2}#3}
\end{figure*}}

% For large/wide figures
%\FigureW{width}{name}{caption}
\newcommand{\FigureWI}[3]{%
\begin{figure*}[htb]
  \centering
  \input{#1.pdf_tex}
  \caption{\label{fig-#1}#2}
\end{figure*}}



%%% ADD COMMENTS=
\usepackage{color} 
\newcommand{\CD}[1]{{\color{magenta}{\textbf{C: #1}}}}

\title[B\'ezier Shell FE]%
      {B\'ezier Shell Finite Element for Interactive Surgical Simulation}

% for anonymous conference submission please enter your SUBMISSION ID
% instead of the author's name (and leave the affiliation blank) !!
% TODO: anonymize -- Submission ID
\author[T. Golembiovský \& C. Duriez]
       {Tomáš Golembiovský$^{1,2}$ and Christian Duriez$^{2}$\\
        $^1$Faculty of Informatics, Masaryk University, Czech Republic\\
        $^2$INRIA Lille, France
       } % TODO: ask Christian how to specify affiliation

% ------------------------------------------------------------------------

% if the Editors-in-Chief have given you the data, you may uncomment
% the following five lines and insert it here
%
% \volume{27}   % the volume in which the issue will be published;
% \issue{1}     % the issue number of the publication
% \pStartPage{1}      % set starting page


%-------------------------------------------------------------------------
\begin{document}

% \teaser{
%  \includegraphics[width=\linewidth]{eg_new}
%  \centering
%   \caption{New EG Logo}
% \label{fig:teaser}
% }

\maketitle

\begin{abstract} % TODO
    TODO: Abstract.

\begin{classification} % according to http://www.acm.org/class/1998/
    \CCScat{Computer Graphics}{I.3.5}{Computational Geometry and Object Modeling}{Physically based modelling};
    \CCScat{Computer Graphics}{I.3.7}{Three-Dimensional Graphics and Realism}{Animation}.
    %\CCScat{Simulation and Modeling}{I.6.8}{Types of Simulation}{Animation}
    %\CCScat{Life and Medical Sciences}{J.3}{Health}{}
\end{classification}

\end{abstract}





%-------------------------------------------------------------------------

\section{Introduction} % {{{

Thin objects are very frequent in our every-day life. % thin wall objects ?
%Objects with thin structure occur in many forms 
e.g. textiles, paper, leaves etc. 
Such objects are also very common in anatomical or pathological structures for example tubular structures (like blood vessels, colon \ldots), thin bag structures (%vessie, 
Glisson capsule, aneurysms,  \ldots), and also many others (eyes, skin, \ldots). 
In the field of surgical simulation, we try to reproduce or anticipate the mechanical behavior of these structures during the surgery.
Thus, it is very important to capture accurately the physical behavior of these structure.
However, in the same time, it is also very important to maintain fast computation rates, in order to be compatible with the targeted applications (interactive simulation for education and for planning).

This problem has been faced by the computer graphics community but for different applications.
For instance, many related works address the problem of the simulation of cloth using mass-spring models \cite{Volino2009} or bending models \cite{Grinspun2003}. %% Todo Choi2007?
However, these models are discrete so their behavior depends on the mesh and their parameters are not easily measurable.
This is completely acceptable for some computer graphics application, where the parameters can be tuned manually to obtain a realistic animation.
In the case of medical simulation, more physics-based modeling is needed.


Methods based on continuum mechanics and namely theory of elasticity gained on popularity in real-time simulations ever since Terzopoulos \cite{Terzopoulos1987} presented his work on elastic deformation modeling.
While the methods using finite elements and theory of elasticity are fairly popular in volumetric modeling of deformations \cite{Cotin1999,Nesme2006,Miller2007}, they are still frowned upon in the area of thin structures. 
Yet, a special field of continuum mechanics has studied the deformations of these objects, and has proposed models based on shell theory.
This theory was integrated numerically using Finite Elements \cite{Reddy1993}, but there are two issues for obtaining interactive frame rates: 
(i) the continuum equations requires second spatial derivations that can not be handled with linear interpolation and 
(ii) the final system of equations that describes the mechanics is non-linear (if the deformations are not small).

The usual argument against non-linear FEM based methods is that they are computationally too expensive. 
This is indeed true if lots of elements are used to discretize the object.
A classical strategy, is to use high-polygonal meshes for rendering or collision detection and response, while maintaining a reasonably low number of elements for the mechanics.
The work of Bouthors et al.\cite{Bouthors2007} is a good application example of this strategy for surface deformations.
But this strategy is not sufficient in our case because the problem of performance is also greatly impacted when using elements that have an interpolation with high order polynomials.
This type of interpolation is necessary because bending continuum model
(based on Kirchhoff-Love theory for thin plates)  requires the computation of second spatial derivatives.
On the other hand, elements common in mechanics (e.g. Discrete Kirchhoff Triangles) are based on shape functions that are impractical for real-time simulations or don't have explicitly defined shape functions at all.
In \cite{Comas2010c}, Comas et al. use a hybrid interpolation: linear interpolation is used for in-plane deformations and cubic polynomials for bending deformations.
The element is piloted by 3 nodes on which 6 degrees of freedom are defined. 
From this point of view, our work is derived from this approach but we address several noted drawbacks: the formulation misses one rotational degree of freedom, the cubic interpolation is not symmetric and produces $C^0$  discontinuities between elements on edges.
Ubach et al. \cite{Ubach2010}  present a shell element based on B\'ezier triangles that allows for a better behavior.
However, the B\'ezier interpolation defined on each triangle element is based on the motion computed on adjacent triangles.
So the stiffness forces computed on each element not only depends on nodes of the element but also on all the adjacent nodes. 
This greatly reduces the sparsity of the global stiffness matrix and consequently increases the computation time.


% TODO: paper structure
TODO: paper structure

\subsection{Contribution}

Extending the work of Comas \cite{Comas2010c} we have designed a shell element that uses B\'ezier interpolation polynomials.
Our element solves the problems of the element presented by Comas:
(i) it uses all 6 degrees of freedom,
(ii) the deformations are completely symmetric and
(iii) the boundary between elements is continuous.
We present a two stage interpolation:
(i) first a kinematic link between 6 DOF nodes of element and nodes of B \'ezier control mesh is defined and
(ii) interpolation function of cubic B\'ezier triangle is applied to interpolate on the surface of the element.
Mapping of high resolution mesh on the curved surface of the shell.
Finally from the kinematic link we derive formulas for
(i) interpolating velocity on the element surface and for
(ii) distribution of normal force applied on the element surface back to 6 DOF nodes of the element.
This allows us to use smooth mapped surface for collision detection and allows the propagation of proper collision response back onto the mechanical mesh.

% }}}


\section{Element Kinematics}\label{sec-kinematics} % {{{

In this subsection we propose an element featuring interpolation with high degree of flexibility while still maintaining low number of degrees of freedom.
We introduce a new way of building the interpolation by using two stages 

\begin{enumerate}
    \item A B\'ezier interpolation with cubic polynomial functions is defined on a triangle.
    \item A kinematic relation between nodes (6DOFs) defined at the vertices and the control points of the B\'ezier triangle.
\end{enumerate}

\FigureWI{stages}
{Two stages of interpolation: First, from triangular with 6DOF nodes (a) a mesh of control points (b) is computed.
Then based on definition of the B\'ezier triangle a surface (c) is interpolated.}

\subsection{B\'ezier Triangle Interpolation} % {{{

In the rest of the document we define the surface over the triangle:
%
\begin{equation}
    (\xi_1,\xi_2) \in \bigtriangleup = \left\{ (\xi_1,\xi_2)~|~\xi_1, \xi_2 \ge 0
        \mathrm{~and~} \xi_1+\xi_2 \le 1 \right\}
\end{equation}
%
B\'ezier triangles were first designed in early sixties by French mathematician de Casteljau.
As with other B\'ezier or B-spline surfaces the B\'ezier triangle is
defined by a mesh of control points that do not necessarily lie on the
surface. The general $n$-th order B\'ezier triangle requires $(n + 1)(n +
2)/2$ control points and it's surface is defined as:
%
\begin{equation}
    T(\xi_1, \xi_2) = \sum_{0 \le i + j \le n} B^n_{i,j}(\xi_1,\xi_2) P_{i,j}
\end{equation}
%
where $P_{i,j}$ are the control points and $B^n_{i,j}$ are the bivariate
Bernstein basis functions defined as:
%
\begin{equation}
  B^n_{i,j} (\xi_1,\xi_2) =
    \binom{n}{i~j} \xi_1^i \xi_2^j (1-\xi_1-\xi_2)^{n-i-j},
\end{equation}
\begin{equation}
  \binom{n}{i~j} = \frac{n!}{i!j!(n-i-j)!}
\end{equation}
%
where $ 0 \le i+j \le n $.

In our work we use cubic B\'ezier triangle ($n=3$). Triangle of smaller order
would fail to describe all possible deformations of the element and
triangles of higher order cannot be described unambiguously with only 18
DOFs available to us without adding further constraints on the control
mesh. Cubic triangle is described by 10 control points and the surface is
explicitly defined as (see fig. \ref{fig-bezier2}):
%
\begin{equation}\label{eq-cubicbez}
  \begin{split}
  T(\xi_1,\xi_2) & =
             \xi_1^3\ P_1
           + \xi_2^3\ P_2
           + \xi_3^3\ P_3 \\
         & + 3\ \xi_1^2 \xi_2\ P_4
           + 3\ \xi_1^2 \xi_3\ P_5
           + 3\ \xi_2^2 \xi_3\ P_6 \\
         & + 3\ \xi_1 \xi_2^2\ P_7
           + 3\ \xi_1 \xi_3^2\ P_8
           + 3\ \xi_2 \xi_3^2\ P_9 \\
         & + 6\ \xi_1 \xi_2 \xi_3\ P_{10} \\
  \end{split}
\end{equation}
%
where $ \xi_3 = 1 - \xi_1 - \xi_2 $. By naming $n_i$ the respective values
of the Bernstein basis functions linked to control point $P_i$ we can
shortly express \eqref{eq-cubicbez} as:
%
\begin{equation}\label{eq-cubicbez2}
    T = \sum_{i=1}^{10} n_i P_i
\end{equation}

\Figure{0.8\linewidth}{bezier2}
{Cubic B\'ezier triangle with mesh of 10 control points.}

% }}}

\subsection{Initial Construction of Control Points} % {{{

The cubic B\'ezier triangles are defined by a mesh of 10 control points each, however the
simulated object is usually described by a triangular mesh possibly with normals.
A procedure for construction of initial B\'zier mesh is necessary.
We construct the initial B\'ezier mesh by taking into account the curvature of the triangular
mesh. Note that special care has to be taken to maintain
the continuity between elements across the nodes and edges, 
we partially employ the method described in \cite{Ubach2010} to maintain
$C^0$ continuity. Each of the control points on the edge is
computed as the intersection of (\CD{Need to do a figure of this}):

\begin{enumerate}
    \item The plane perpendicular to the normal at the vertex.
    \item The plane that contains the curve of triangle's contour. The
        choice is arbitrary, but necessary to maintain $C^0$ continuity. 
        We choose the plane defined by the edge of the flat triangle and
        average of the two normals at vertices of the edge. 
    \item The plane perpendicular to the edge of the flat triangle placed at
        $1/3$ of the edge length.
\end{enumerate}

Notice that the points on the edge will be same for both triangles sharing
the edge.

$C^1$ continuity between elements on the edges can also be maintained if special care is taken
when computing the position of the central point
(see \cite{Ubach2010} or refer to the work of Farin \cite{Farin2002} for continuity conditions). 
For simplicity we decided to keep the edge boundary only $C^0$ continuous and we compute the central point as a function of other 9 points: 
%
\begin{equation}\label{eq-central}
    P_{10} = \frac{1}{3}(\sum_{i=4}^9 P_i - \sum_{i=1}^3 P_i)
\end{equation}
%
where the points $P_i$ are named as in Figure \ref{fig-bezier2}.

That way if the element is not flat the central point is slightly elevated
and not in the plane of other points thus keeping the curvature of the
element.

% }}}

\subsection{Kinematic Between Nodes and Control Points } % {{{

With 10 control points and 3 DOFs per point it is a total of 30 DOFs for triangle.
Simulation of such complex system would significantly reduce the sparsity of stiffness matrix.
We propose a reduction of the number of degrees of freedom by using 3 nodes with 6 degrees of freedom
by creating a kinematic link between the control points.
Each of the edge control points is attached to nearest corner node. See Figure
\ref{fig-segments2} for the correspondence between edge points and
associated corner nodes. 
In the following text the index $j \in [4;10]$ refers to edge points and index $i \in [1;3]$ to the associated corner point/node (unless $i$ is explicitly used differently).

\Figure{0.8\linewidth}{segments2}
{Internal nodes of control mesh are connected to the corner nodes by kinematic link (shown in blue).}

In the initialization phase we remember the position of edge point $j$ in the frame of corner point $i$:
%
\begin{equation}
    \overline{P_{i-j}} = R(\theta_i^0)^T P_{i-j}^0
\end{equation}
%
where
$\mathbf{x}_i$ and $\theta_i$ are the position and angular position of the node $i$,
$R(\theta_i^0)$ is the rotation matrix for the angular position of node $i$ at the beginning of the simulation and
$P_{i-j}^0 = P_j^0 - \mathbf{x}_i^0 = P_j^0 - P_i^0$ the attachment segment.

In each step of the simulation we
%recompute the new position based on current orientation of the corner node:
apply the rigid transformation of frame $i$ on control point $j$:
%
\begin{equation}
    P_j = \mathbf{x}_i + P_{i-j} = P_i + R(\theta_i) \overline{P_{i-j}}
\end{equation}

Similarly for the central point we apply rigid transformation of all frames of the triangle and compute the mean:
%
\begin{equation}\label{eq-central2}
    P_{10} =  \frac{1}{3}\left( \sum_{i=1}^3 \mathbf{x}_i + R(\theta_i) \overline{P_{i-10}} \right)
\end{equation}

Putting previous equations into \eqref{eq-cubicbez2} we get:
%
\begin{equation}\label{global-transform} \begin{split}
    & T = \sum_{i=1}^{10} n_i P_i = \sum_{i=1}^{3} n_i \mathbf{x}_i
    + \sum_{j=4}^9 n_j  \left(
        \mathbf{x}_i + R(\theta_i) \overline{P_{i-j}} \right) + \\
    &\quad + \frac{n_{10}}{3}
        \left( \sum_{i=1}^3 \mathbf{x}_i + R(\theta_i) \overline{P_{i-10}} \right)
    \end{split}
\end{equation}

% }}}


\subsection{Deflection Function} % {{{

% explicit {{{
%We recall the equation for central node \eqref{eq-central} and
%considering how are the edge points of control mesh connected to corner points with
%segments $P_{i-j}$:
%
%\begin{equation}
%    P_{i-j} = P_j - P_i, \quad j \in [4;9], i \in [1;3].
%\end{equation}
%
%We now add small variation to the position ($U_1, U_2, U_3$) and orientation ($\theta_1, \theta_2, \theta_3$) of corner nodes to the equation of the element \eqref{eq-cubicbez}:
%
%\begin{equation}
%    \begin{split}
%        & n_1 (P_1 + U_1)
%        + n_2 (P_2 + U_2)
%        + n_3 (P_3 + U_3) \\
%        & + n_4 (P_1 + U_1 + P_{1-4} + P_{1-4} \times \theta_1)
%        + n_5 (P_1 + U_1 + P_{1-5} + P_{1-5} \times \theta_1) \\
%        & + n_6 (P_2 + U_2 + P_{2-6} + P_{2-6} \times \theta_2)
%        + n_7(P_2 + U_2 + P_{2-7} + P_{2-7} \times \theta_2) \\
%        & + n_8 (P_3 + U_3 + P_{3-8} + P_{3-8} \times \theta_3)
%        + n_9 (P_3 + U_3 + P_{3-9} + P_{3-9} \times \theta_3) \\
%        & + n_{10} \frac{1}{3} \left(
%        \sum_{i=1}^3 (P_i + U_i + P_{i-10} + P_{i-10} \times \theta_i)
%        \right) \\
%%
%        & = 
%    \sum_{i=1}^{10} n_i P_i
%      + n_1 U_1
%      + n_2 U_2
%      + n_3 U_3 \\
%      & + n_4 (U_1 + P_{1-4} \times \theta_1)
%      + n_5 (U_1 + P_{1-5} \times \theta_1)
%      + n_6 (U_2 + P_{2-6} \times \theta_2) \\
%      & + n_7 (U_2 + P_{2-7} \times \theta_2)
%      + n_8 (U_3 + P_{3-8} \times \theta_3)
%      + n_9 (U_3 + P_{3-9} \times \theta_3) \\
%      & + n_{10} \frac{1}{3} (U_1 + U_2 + U_3 + \sum_{i=1}^3 P_{i-10} \times \theta_i) \\
%%
%      & = T + U_1 (n_1 + n_4 + n_5 + \frac{1}{3} n_{10}) \\
%      & + U_2 (n_2 + n_6 + n_7 + \frac{1}{3} n_{10}) \\
%      & + U_3 (n_3 + n_8 + n_9 + \frac{1}{3} n_{10}) \\
%      & + \sum_{j=4}^9 n_j P_{i-j} \times \theta_i
%      + n_{10} \frac{1}{3} \sum_{i=1}^3 P_{i-10} \times \theta_i \\
%%
%      & = T + u
%  \end{split}
%\end{equation}
%}}}

A small variation $\delta \mathbf{x}_i$ of the node $i$ position and $\delta \mathbf{\theta}_i$ for the rotation produces the following small variation of position corner points $\delta P_i$ and edge points $\delta P_j$:
%
\begin{eqnarray}
    \delta P_i & = & \delta \mathbf{x}_i \\
    \delta P_j & = & \delta \mathbf{x}_i +  P_{i-j} \times \delta \mathbf{\theta}_i
\end{eqnarray}
%
and variation of central point $\delta P_{10}$:
%
\begin{equation}
    \delta P_{10} = \frac{1}{3} \sum_{i=1}^3 \left(
    \delta \mathbf{x}_i + P_{i-10} \times \delta \mathbf{\theta}_i \right)
\end{equation}

Thus, finally, it creates a variation of the point position on the surface $\delta T$:
%
\begin{equation}
    \delta T = \sum_{i=1}^{10} n_i  \delta P_i
\end{equation}
%
or:

\begin{equation}\label{eq-bez-delta}
    \begin{split}
        \delta T = &   (n_1 + n_4 + n_5 + \frac{1}{3} n_{10})  \delta \mathbf{x}_1 + \\
                   & + (n_2 + n_6 + n_7 + \frac{1}{3} n_{10})  \delta \mathbf{x}_2 + \\
                   & + (n_3 + n_8 + n_9 + \frac{1}{3} n_{10})  \delta \mathbf{x}_3 + \\
                   & + \sum_{j=4}^9 n_j P_{i-j} \times \delta \mathbf{\theta}_i + \\
                   & + \frac{n_{10}}{3} \sum_{i=1}^3 P_{i-10} \times \delta \mathbf{\theta}_i 
    \end{split}
\end{equation}

We have simplified the notation by leaving the variable $i$ free in the above sums ($\sum_{j=4}^9$) involving $P_{i-j}$.
Note however that the expressions are sound and unambiguous because there is only one possible $i$ for each $j$ depending on the connection of segments to the corner nodes (see fig. \ref{fig-segments2}).

% }}}

% }}}

%%%%%%%%%%%%%%%%%%%%%%%%% SECTION 3 %%%%%%%%%%%%%%%


\section{Finite Element Formulation} % {{{

In the previous section we present an interpolation based on cubic B\'ezier triangles and a kinematic link between the control points and the element 6DOF nodes.
In this section we show how this interpolation can be used to compute a finite element formulation of the shell equations.
The model relies on large transformation formulation: the geometrical non-linearities are handled using a corotational formulation, whereas, in the frame of the element, infinitesimal strain theory is used.


\subsection{Computation of the Strain Tensor} % {{{

(\CD{TODO add a figure to illustrate the explanation})

We define a local system of coordinates $(x,y,z)$ in which the axis z is oriented along the thickness of the element (the computation of the frame of each element will be detailed in section \ref{sec-corot}). 
Given the initial position of the triangle points in this system of coordinate, $\{x_1^0, y_1^0\}$,  $\{x_2^0, y_2^0\}$, and  $\{x_3^0, y_3^0\}$, we can compute a linear relation between $\{\xi_1,\xi_2, \xi_3\}$ and $\{ x,y \}$:
%
\begin{equation}
\label{shape-vector}
\left[ \begin{array}[c]{c} \xi_1(x,y) \\ \xi_2(x,y) \\ \xi_3(x,y) \end{array} \right] =
\left[ \begin{array}[c]{ccc}
1 & 1 &  1 \\
x_1^0 & x_2^0 & x_3^0 \\
y_1^0 & y_2^0 & y_3^0
\end{array} \right] ^{-1} 
\left[ \begin{array}[c]{c} 1 \\ x \\ y \end{array} \right] 
\end{equation}

Thus, we can locally compute some spatial derivatives, along $x$ and $y$ on the interpolation function vector $T$ (which has three components $(T^x, T^y, T^z)$) .
The 2D tensor $F$ of the in-plane deformations can be computed as a $2\times2$ matrix where the line $k$ and the column $l$ alternatively represent $x$ and $y$:
%
\begin{equation}
    F_{kl} = \deriv{T^k}{l}  = 
    \sum_{i=1}^3 \deriv{T^k}{\xi_i} \deriv{\xi_i}{l};
    \quad k \in \{x,y\}, l \in \{x,y\}
\end{equation}

The term $\deriv{T^k}{\xi_i}$ can be derived from the expression of $T(\xi_1,\xi_2, \xi_3)$ in equation (\ref{global-transform}) and 
$\deriv{\xi_i}{l}$ from equation (\ref{shape-vector}). 
The in-plane displacement gradient can be obtained with tensor $F$:
%
\begin{equation}
\deriv{u^k}{l} = F_{kl} - I_{kl} 
\end{equation}
%
where $\mat{I}$ is the identity matrix ($I_{kl}  = \{1$ if $l=k$ ;  $0$ if $l \neq k \} $). 
The displacement gradient can be linked to the degrees of freedom of the shell using the expression of the displacement of a point $\delta T$ (see equation  (\ref{eq-bez-delta})) on the shell surface:
\begin{equation}
    \nabla u = \nabla(\delta T)
\end{equation}

In the local frame of the element, we rely on infinitesimal strain theory, thus the expression of the strain tensor (using Voigt notations) is:
\begin{equation}\label{eq-in-plane-strain}
    \begin{bmatrix}
        \epsilon_{xx} \\ \epsilon_{yy} \\ 2\epsilon_{yx}
    \end{bmatrix}
    = 
    \begin{bmatrix}
        \deriv{u^x}{x}  \\[1mm]  \deriv{u^y}{y}  \\[1mm]  \deriv{u^x}{y} + \deriv{u^y}{x}
    \end{bmatrix}
\end{equation}

For the bending formulation, the shell theory uses a measure of the out of plane-displacement $u^z(x,y)$
The strain tensor is based on Kirchhoff-Love theory for thin plates:
\begin{equation}\label{out-plane-strain}
    \begin{bmatrix}
        \epsilon_{xx} \\ \epsilon_{yy} \\ 2\epsilon_{yx}
    \end{bmatrix}
    =
    \begin{bmatrix}
        -z \deriv{^2 u^z}{x^2}  \\[1mm]  -z \deriv{^2 u^z}{y^2}  \\[1mm]  - 2z \deriv{^2 u^z}{xy}
    \end{bmatrix}
\end{equation}
where $z$ is the local coordinate along $z$-axis of the point on which the strain is measured.


As the term $\deriv{\xi_i}{l}$ provides a constant value, the second derivatives can be computed quite easily, for instance, for $\epsilon_{xx}$:
\begin{equation}
    \deriv{^2 u^z}{x^2}
    = \sum_{i=1}^3 \deriv{}{\xi_i}\left(
        \sum_{j=1}^3 \deriv{T^z}{\xi_j} \deriv{\xi_j}{x}
    \right) \deriv{\xi_i}{x} 
    = \sum_{i=1}^3 \sum_{j=1}^3  \deriv{^2 T^z}{\xi_i\xi_j}  \deriv{\xi_j}{x}  \deriv{\xi_i}{x}  
\end{equation}

% }}}



\subsection{Shell Element} % {{{

As previously described, the shell element's strain is a combination of two types of deformations, as shown in figure \ref{deformations}.
If we assume that the initial out of plane deflections are negligible and that the frame of the shell element nodes are aligned with local $z$ axis, we can distribute these two deformations into two groups of degrees of freedom  at the nodes' level.

\FigureWI{deformations}
{Plate deformations:
a) membrane deformations like stretching or shearing, due to in-plane displacements
b) undeformed;
c) bending deformation, due to out of plane displacements
\label{deformations}}

\begin{itemize}

    \item Elastic membrane defining deformations in plane of the
    element. It encompasses deformations like stretching and shearing.
    It corresponds to the in-plane displacements $u_x, u_y$. 
    At the nodes' level, it corresponds to in-plane displacements $\delta\mathbf{x}_x, \delta\mathbf{x}_y$ and rotation $\theta_z$.

    \item Bending plate defining deformation due to out of plane bending displacement $u_z$. It is
    influenced by 3 degrees of freedom: rotation around two axes $\theta_x,
    \theta_z$ and out of plane displacement $\delta\mathbf{x}_z$.

\end{itemize}

Combining both elements we make use of all 6 degrees of freedom available
at each node of the element.

% }}}

\subsection{Stiffness Matrix} % {{{

In order to compute FEM-based stiffness for the shell element, we need to compute the jacobian matrix between strains and nodes' displacements.
As we have separated the formulations for the in-plane and the out of plane displacements, it will result with the computation of two jacobian matrices (of size $3\times9$).
\begin{equation}
    \delta 
    \begin{bmatrix}
        \epsilon_{xx} \\ \epsilon_{yy}  \\ 2\epsilon_{yx}
    \end{bmatrix}
    = \begin{bmatrix} \mat{J}_m \end{bmatrix}
    \begin{bmatrix}
        \delta \mat{x}_1^x \\ \delta \mat{x}_1^y \\ \delta \theta_1^z \\ \vdots
    \end{bmatrix}
\end{equation}
where $\left[ \mat{J}_m \right]$ maps the membrane in-plane displacements and 
%
\begin{equation}
    \delta
    \begin{bmatrix}
        \epsilon_{xx} \\ \epsilon_{yy}  \\ 2\epsilon_{yx}
    \end{bmatrix}
    = \begin{bmatrix} \mat{J}_b \end{bmatrix}
    \begin{bmatrix}
        \delta \mat{x}_1^z \\ \delta \theta_1^x \\ \delta \theta_1^y \\ \vdots
    \end{bmatrix}
\end{equation}
where $\left[ \mat{J}_b \right]$ maps the bending displacements.

To compute the values in matrices $\left[ \mat{J}_m \right]$ and $\left[ \mat{J}_b \right]$,  we can reuse equation (\ref{eq-bez-delta}) and apply the spatial derivatives.
To illustrate, let's take one value of the matrix $\left[ \mat{J}_m \right]$  (first line, fourth column), we first take the kinematics between $\delta T_x$ and the concerned degree of freedom $ \delta \mathbf{x}_2^x$ from equation (\ref{eq-bez-delta}):
\begin{equation}
    \frac{ \delta T_x }{ \delta \mathbf{x}_2^x } = (n_2 + n_6 + n_7 + \frac{n_{10}}{3})
\end{equation}

Then, we apply the spatial derivatives to compute the variation of $\epsilon_{xx}$ due to a variation of $\mathbf{x}_{2x}$:
\begin{equation}
    \delta \epsilon_{xx} += 
    \underbrace{\left(
    \sum_{i=1}^{3} (\deriv{n_2}{\xi_i} + \deriv{n_6}{\xi_i} + \deriv{n_7}{\xi_i} + \frac{1}{3}\deriv{n_{10}}{\xi_i})
    \deriv{\xi_i}{x} \right) }_{\begin{bmatrix} \mat{J}_m \end{bmatrix}_{14}}  
 \delta \mathbf{x}_2^x 
\end{equation}

Assuming constant thickness $t$ of the element and integrating over the volume
of the element we compute the stiffness matrices for the elastic membrane
and bending plate respectively:

\begin{align}
    \label{eq-Km}
    \mat{K}_m & = \iiint_V \mat{J}_m^T \mat{M} \mat{J}_m \, \mathrm{d} V \\
    \label{eq-Kb}
    \mat{K}_b & = \iiint_V \mat{J}_b^T \mat{M} \mat{J}_b \, \mathrm{d} V
\end{align}

\noindent
where $\mat{M}$ is the material matrix. To keep the system simple we use linear
Hooke's law for isotropic materials.

Because the deflection field for the element is non-linear \eqref{eq-bez-delta}
in position the integrals \eqref{eq-Km} and \eqref{eq-Kb} have to be computed using
numerical integration. In our implementation we employ 6-point Gaussian
quadrature for integration over triangle area.
\CD{TODO: figure + gives the formula of the quadrature...}
% TODO: add ref
% TODO: add abscissas/weights?

% }}}

\subsection{Corotational Formulation} % {{{
\label{sec-corot}

It is known that the Cauchy's strain tensor \eqref{eq-in-plane-strain} is not
rotation invariant \cite{Hauth2004,Muller2004} and produces ghost forces for rigid
rotations. The alternative approach is to use non-linear Green's strain tensor but the non-linearity introduced into the system is costly and introduces instabilities.
To keep the system linear and to deal
with rigid body rotations we compute the displacements and forces in
corotational frame. At each step of the simulation we compute the local
frame for every element, the resulting internal force of deformed element
is then computed relative to this frame:
%
\begin{equation}
    F_e = \mat{R}_e^T (\mat{K}_e u) = \mat{R}_e^T \left(\mat{K}_e(\mat{R}_e x - \mat{R}_e^0 x^0)\right)
\end{equation}
%
where $\mat{R}$ and $\mat{R}_0$ are rotation matrices of the frame for current and rest
mesh respectively.

The corotational frame is computed using following steps: 

\begin{itemize}
    \item One axis is aligned to one edge of the element:\\
    $\mathbf{e}_1 = \mathbf{x}_2 - \mathbf{x}_1$
    \item A normal to the plane of the element is computed:\\
    $\mathbf{e}_3 = \mathbf{e}_1 \times (\mathbf{x}_3 - \mathbf{x}_1)$
    \item Second axis in the plane of the element is computed:\\
    $\mathbf{e}_2 = \mathbf{e}_1 \times \mathbf{e}_3$
\end{itemize}

Correct choice of the corotational frame is a tricky
problem \cite{Felippa2005} and incorrect frame for the membrane element can
have adverse effects on the simulation.
This choice of the frame where we align one axis with one of the edges
of the triangle is not a perfect one and we have experienced
non-negligible difference in deformation of equilateral triangle depending
on whether an axis was aligned to the edge favored by the deformation or to
one of the two other edges.

A polar decomposition on the deformation gradient $F = \nabla u
+ \mat{I}$ can be used to extract a rotation component from the deformation of
the element \cite{Ciarlet1994,Hauth2004}. Because we are only fixing the membrane
element we can perform the polar decomposition in 2D with the following
formula:
%
\begin{equation}
    \mat{R} = \mat{F} + \mathrm{sgn}(\mathrm{det}(\mat{F})) \begin{pmatrix}
        F_{22} & - F_{21} \\
        F_{12} & F_{11}
    \end{pmatrix}
\end{equation}
%
and subsequently normalizing the columns. We then rotate the corotational
frame in opposite direction. Even single step of this process improves the
final frame but more iterations of the polar decompositions are usually
necessary (up to 20) which severely degrades the performance. Polar
decomposition tends to "overshoot" the ideal rotation angle and each
subsequent step performs a rotation in the direction opposite to the rotation in previous step. By properly
scaling the rotation angle we are able to minimize the amount of needed
iterations down to 5. The best value for the scaling factor depends on the
simulated problem, but we have experimentally localized the best value to
be somewhere between 0.6 and 0.65. We choose to use the value 0.61.

We employ two stop conditions for the iteration process:
(i) the change in rotation angle is less than $10^{-6}$, and
(ii) the maximum number of iterations is set to 5.

If the first condition is not met in 5 iterations it can mean one of three
things we still have very good approximation of the ideal frame. In some
situations the process is not able to reach the ideal frame quickly because
either the convergence for the element is too slow or the process is diverging.
In either case performing more iterations is unnecessary.

% TODO: maybe make a short table showing the convergence to the symmetric
% solution.


% }}}

% }}}

%%%%%%%%%%%%%%%%%%%%%%%%% SECTION 4 %%%%%%%%%%%%%%%

\section{Application of High Resolution Mesh} % {{{

Because of the bending property of the shells relatively few elements are
necessary to simulate curved surface. To enrich the visual experience from
the simulated object it is desirable to use more triangles in the areas
with high curvature during rendering. Besides the visual accuracy the high
resolution mesh correctly modeling the curved areas is needed for
interaction and correct simulation of collisions and constraints. To handle
these we also need to know how to map the velocities from the mechanical
mesh onto the high resolution mesh and how to map forces acting on the high
resolution mesh back onto the mechanical mesh.

\subsection{Surface Mesh}

To project vertices onto the surface of shells 
we use the fact that the geometry of is based on the formulation
of cubic B\'ezier triangle \eqref{eq-cubicbez}. For every vertex of the high
resolution mesh we first find the corresponding triangle on the mechanical
mesh that is closest to the vertex and assign barycentric coordinates on
the triangle to this vertex. After every step of the simulation points of the
control mesh are updated based on the kinematic link described in
section \ref{sec-kinematics} and the high
resolution mesh is updated using the assigned barycentric coordinates and
the function of the surface \eqref{eq-cubicbez}.

\subsection{Nodal Velocities of the Surface Mesh}

For contact modeling it is often necessary to know the velocity of each point.
The values are directly available to us for the nodes of the mechanical mesh
but they can also be computed for any point on the surface.
Differentiating \eqref{eq-cubicbez2} by time we get:
%
\begin{equation}
    \dot{T} = \sum_{i=1}^{10} n_i \dot{P_i} = \sum_{i=1}^{10} n_i V_i
\end{equation}

Which means we use the same expression to interpolate the velocity only by
substituting the velocities at control points. For the corner nodes we
already have the velocities $V_i$. For the internal nodes we need to compute
them. We again make use of the kinematic link between nodes and solve the
problem of computing the velocity of a point attached to the moving rigid body.
For the edge points we have:
%
\begin{eqnarray}
    V_j = V_i + \omega_i \times P_{i-j}
\end{eqnarray}
%
where $i$ is the index of the corner node the edge node is attached to and
$\omega_i$ is the angular velocity at the node. For the central node
the formula is based on \eqref{eq-central2}:
%
\begin{eqnarray}
    V_i = \frac{1}{3} \sum_{i=1}^3 \left( V_i + \omega_i \times P_{i-10} \right)
\end{eqnarray}

\subsection{Projection of Normal Forces}

For physical interaction with the object one also requires that the normal
forces applied on the object's surface are transmitted back as forces
and torques on the vertices of the mechanical mesh.
We compute the influence of force $F$ on the corners through all the
associated control points by the formula:
%
\begin{eqnarray}
    F_1 & = & F \sum_{i \in \{1,4,5\}} n_i + \frac{n_{10}}{3} F \\
    F_2 & = & F \sum_{i \in \{2,6,7\}} n_i + \frac{n_{10}}{3} F \\
    F_3 & = & F \sum_{i \in \{3,8,9\}} n_i + \frac{n_{10}}{3} F 
\end{eqnarray}

Similarly we can compute the torques applied through edge control points and
the central control points:
%
\begin{gather}
    \begin{split}
        \theta_1 = & P_{1-4} \times (n_4 F) + P_{1-5} \times (n_5 F) + \\
        & + \frac{1}{3} P_{1-10} \times (n_{10} F)
    \end{split}
    \\
    \begin{split}
        \theta_2 = & P_{2-6} \times (n_6 F) + P_{2-7} \times (n_7 F) + \\
        & + \frac{1}{3} P_{2-10} \times (n_{10} F) \\
    \end{split}
    \\
    \begin{split}
        \theta_3 = & P_{3-8} \times (n_8 F) + P_{3-9} \times (n_9 F) + \\
        & + \frac{1}{3} P_{3-10} \times (n_{10} F) \\
    \end{split}
\end{gather}

% }}}

\section{Validation and Results} % {{{

% We cannot show results for simple plane in bending because the solution
% seems to converge to wrong value (but it converges! :)). Thus showing
% results for plain membrane deformations doesn't make sense (it would be
% inconsistent).

% TODO:
% \CD{ - On this section,  we can maybe add some results from the CBM paper you did with Stephan especially  the figure 9 that illustrates the 3d contribution we list in the intro: i.e. Mapping of high resolution mesh on the curved surface of the shell.}
% Not enough space?

In subsections \ref{sec-roof} and \ref{sec-hemisphere} we present tests to
validate the convergence of our B\'ezier shell element. As a reference we use a
combination of two elements that are very well established in the area of
mechanical modelling. Our results are compared with the shell element composed
of Discrete Kirchoff Triangle (DKT) element \cite{Batoz1980} for bending plate
and optimal ANDES element \cite{Felippa2003} for membrane. For comparison the
results for the model of O. Comas are also presented. Subsection \ref{sec-fps}
presents evaluation of the computational complexity of our solution. Last
subsections are dedicated to presentation of application of our model.


\subsection{Roof Test}\label{sec-roof}

To validate the results of the element we have performed a modified version
of a test known as Scordelis-Lo roof. It simulates a cylindrical roof under
self-weight. The geometry is defined by 80° cylindrical patch of length
$L=50$, radius $r=25$ and thickness $t=0.25$ and is discretized into
mesh of NxN vertices. The physical parameters are $E = 4.32 \times 10^8$ and
$\nu = 0$. The roof is loaded with uniformly distributed load $q = 90$ per
unit area. The curved edges are clamped at both ends to avoid rigid body
movement. This is the only difference from the original Scordelis-Lo roof test
where the edges are free to move in longitudinal direction. The Figure
\ref{fig-roof} shows the vertical displacement of midpoint on the free
edge.

\Figure{\linewidth}{roof}
{Convergence for modified Scordelis-Lo roof test of DKT+ANDES element, 
our B\'ezier shell element (BSH) and element of O. Comas (PSH) with polynomial shape function.}

\Figure{\linewidth}{roof-img}
{Coloured plot of vertical displacement in the roof test}


\subsection{Hemisphere Test}\label{sec-hemisphere}

Second performed test is a hemisphere with hole subjected to two opposing
forces at the base. The geometry is described by a hemisphere with radius
$r=10$ and thickness $t=0.04$ with 18° hole at the top and the geometry is
discretized into the grid of NxN vertices per quadrant. The physical
parameters are $E = 6.825 \times 10^7$ and $\nu = 0.3$. The hemisphere is
at it's base subjected to two opposing outwards forces and two opposing
inwards forces with magnitude $P = 4$. To avoid rigid body movement we have
constrained two opposite nodes at the top of the hemisphere. The radial
displacement for one point with applied load is shown in Figure
\ref{fig-hemisphere}.

\Figure{\linewidth}{hemisphere}
{Convergence for test on hemisphere with 18° hole for the DKT+ANDES element and
our B\'ezier shell element (BSH) and element of O. Comas (PSH) with polynomial shape function.}

\Figure{\linewidth}{hemisphere-img}
{Coloured plot of radial displacement in the hemisphere test}


\subsection{Computation Speed}\label{sec-fps} % {{{

In figure \ref{fig-fps} we present performance of the element in terms of
frames per second. All tests were performed on machine equipped with Dual-Core
AMD Opteron Processor 2218 and 3~GB of RAM. We used a conjugate gradient solver
to solve the system. Our implementation is without optimizations
and isn't parallel, which means only single CPU core was used for the
simulation. The values reported are for the raw physical simulation with (b)
and without (a) the frame fixing method described in subsection
\ref{sec-corot}. We also present results including the mapping of
high-resolution mesh onto the mechanical mesh for visualisation purposes or
collisions.

\Figure{\linewidth}{fps}
{Performance in frames per seconds for different number of elements. Shows
values for element with frame fixing (B) method described in subsection
\ref{sec-corot} and without it (A), and with mesh of 3\,200
(C) or 10\,082 (D) triangles mapped onto the mechanical mesh.}

We can see that the frame fixing technique is really fast and we are able
to simulate up to 1\,000 elements and still maintain visual refresh rate of
25 FPS. While our implementation was only single-threaded and the mechanical mapping
wasn't off-loaded to another CPU core we were still able to provide good
results for more than 600 elements mesh with 10k triangles.

% }}}


\subsection{Planning of Congenital Heart Disease Correction Surgery} % {{{

Surgical interventions in infants with congenitally malformed great arteries
and hearts are extremely challenging due to the complex and heterogeneous
nature of their disease patterns. At present, cardiac surgeons rely on
non-invasive imaging for patient-specific examination and a set of preoperative
sketches with varying approaches to the surgical procedure. However, the most
promising approach is often chosen during the actual open-heart surgery, when
surgeons get a more concrete idea of possible outcomes. Finalizing this
decision during an on-pump cardiac surgery is further complicated by deflated
blood vessels since it is difficult to imagine their exact change of shape
caused by the intervention. The important decisions have to be made in very
short time and are strongly dependent on the surgeon's experience.

The planning process can be improved by employing surgical simulation system
using three-dimensional heart models based on patient-specific images as input.
Most present simulation systems focus on execution of low-level surgical
procedures, e.g. incising and suturing. In these reactive simulation systems it
is more important to enable simulations in real-time than accurate simulation
of tissue and blood vessel deformation in response to simulated interventions.

To be able to predict results of complex surgical procedures a physically more
accurate approach is necessary. Using our shell finite element model we have
developed a prototype \cite{Kislinskiy2012} of new surgical simulation system
for preoperative planning. The element has been used to model deformations of
blood vessels and artificial patch. By performing a set of topological changes
we simulate the process of incising the vessel and suturing on a pre-specified
boundary. By iteratively adjusting the underlaying mesh we search for the
elastic equilibrium. Figure \ref{fig-chd} presents a screenshots of the
application prototype.

%%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%
%% TODO: is this OK for anonymity?
%The presented element has been successfully implemented in SOFA framework
%\cite{Faure2012} for real-time surgical simulations. It has been evaluated
%on several applications.
%

\FigureW{0.75\linewidth}{chd}
{Screenshots of the simulation system prototype for different surgical
procedures used to repair a coarctation of an aortic arch. The screenshots
are enriched with overlay delineations.}

% }}}

% TODO?
%Another designed application is simulation of women reproductive organs
%(vagaina/uterus/\ldots). 
%The simulation is so as to evaluate
%stress on a tissue during a birth.


% }}}

\section{Discussion and Limitations} % {{{

Currently, due to the technical decisions the element has two limitations.
The first limitation is that the element does not provide $C^1$ continuity
across edges. It is $C^1$ continuous at corners but only $C^0$ on the
edges. This may prove to be an issue for example if curvature needs to be
computed not only inside the element but also on the edges.

The second limitation is the choice of rigidly attached edge control
points. While it greatly simplifies the formulation the rigidity may cause
issues. In case of large compression of the element the results may be
unpredictable. This is however unlikely to occur because the element will
bend before reaching such configuration. It may, however, fail to maintain
even curvature of the surface if the element is subjected to large
stretching.

On the other hand the choices provide a good trade-off between continuity
and simplicity. Only $ 3 \times 6~\mathrm{DOFs} = 18~\mathrm{DOFs}$ are
necessary while the B\'ezier triangle has theoretically $ 10 \times
3~\mathrm{DOFs} = 30~\mathrm{DOFs}$. For complex elements with high number
of nodes the interconnection between nodes increases, especially on the
vertices where the size of nodes involved depends also on number of
neighbouring elements. By keeping the element simple the sparsity of
stiffness matrix is not violated.

% }}}

\subsection{Conclusion} % {{{

In this paper we presents new shell element with interpolation functions
based on B\'ezier triangle which is more suitable for real-time simulations than elements common in mechanics with complex, obscure or unclear interpolation functions.
It fixes problems of the previous model \cite{Comas2010c} based on cubic polynomials, namely:

\begin{itemize}

    \item Element is based on all 6 DOFs, including the drilling degree of
        freedom, not just 5 DOFs. Therefore it doesn't have the problem of
        undefined z-rotations.

    \item Deformations of the element are symmetric. A method of improving
    the corotational frame to keep the deformation symmetric is also
    presented in the paper.

    \item It is $C^0$ continuous on the edges and provides $C^1$ continuity in
    corners of the element. This is essential for good visual experience if
    high-resolution mesh is mapped on the mechanical mesh.

    % TODO: check this:
    % + Better conditioning (comparison between Comas model and ours in term of
    %   convergence of CG...) 

\end{itemize}

Unified formulation of the deformation allows for derivation of three-dimensional 
stress tensor. This however remains as topic for future work and
we have kept the computation of membrane stresses separate from bending stresses.

Because of the formulation of B\'ezier triangle that is intrinsically present
there is a clean and obvious way of mapping high-resolution mesh for
better visualisation. We also provide a mapping of forces and velocities
between simulation mesh and mechanical mesh for collision detection/response
and interaction with the mesh which are essential component for the surgical
simulator.

Finally examples showing the convergence to the optimal solution were also provided. 

% }}}

%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}

\bibliography{vriphys2012.bib}

\end{document}

% vim: fdm=marker
